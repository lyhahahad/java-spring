JVM 심화학습
https://velog.io/@litien/JVM-%EA%B5%AC%EC%A1%B0
https://d2.naver.com/helloworld/1230

하이라이트
1.자바는 WORA를 목적으로 만들어졌다. 플랫폼 독립성을 추구한다.
2.자바 바이트코드는 JRE위에서 동작하는데 이는 자바 API와 JVM으로 구성돼있다.
3.레지스터 기반이 아니라 스택 기반으로 동작한다.
4.라이브러리를 업데이트 한 상황에서 같은 함수이름을 가진 것이 업데이트 한 라이브러리에 있는데 함수가 없다는 에러가 발생하는 이유는
애플리케이션 class 파일이 업데이트전 라이브러리로 컴파일돼있기 때문이다.
5.C,C++ 컴파일러는 CPU가 읽을 수 있는 코드를 반환하는 반면 자바 컴파일러는 WORA를 구현하기 위해 자바 바이트코드를 반환한다.
6.소스코드-javac-> 자바 바이트코드 -자바 바이트코드-> 어셈블리 프로그램.

-JVM이란?
jvm은 자바 바이트 코드를 실행할 수 있는 주체로 jvm덕분에 cpu나 운영체제와 독립적으로 동작이 가능하다.
jvm은 크게 class loader, garbage collector, excute engine로 나뉜다.
더 정확하게 보면 자바 바이트코드는 JRE위에서 동작한다.
JRE는 자바 API와 JVM으로 구성되어 있다.
JVM은 자바 애플리케이션을 클래스 로더를 통해 읽어 들여서 자바 API와 함께 실행합니다.
JVM은 가상 머신(virtual machine)이란 여러 가지로 정의할 수 있지만, 
프로그램을 실행하기 위해 물리적 머신(즉, 컴퓨터)와 유사한 머신을 소프트웨어로 구현한 것을 말한다고 할 수 있다. 
지금은 비록 빛이 바랜 목표이긴 하나 자바는 원래 WORA(Write Once Run Anywhere)를 구현하기 위해 
물리적인 머신과 별개의 가상 머신을 기반으로 동작하도록 설계되었다.
보통 연산자를 저장할 때는 레지스터를 쓴다. 스택을 쓰는 이유가 무엇일까?
=>자바는 다기종 디바이스에서 동작하기를 원했다. 
=>다기종 디바이스는 레지스터 수가 다 다르다.
=>때문에 조금 복잡하더라고 스택을 사용하는 것이다.

-자바 바이트코드
wora를 구현하기 위해 jvm은 사용자 언어와 기계어 사이에 자바 바이트코드를 사용한다.
애플리케이션 코드를 그대로 두고 라이브러리를 업데이트 한 상황에서
Exception in thread "main" java.lang.NoSuchMethodError: com.nhn.user.UserAdmin.addUser(Ljava/lang/String;)V  
다음과 같은 에러가 발생하는 이유는 jvm의 작동 방식과 연관이 있다.
애플리케이션 코드를 새로운 라이브러리로 다시 컴파일하지 않았기 때문이다.
NoSuchMethodError는 메서드를 찾지 못했을 때 발생한다.
"Ljava/lang/String;"과 마지막의 "V"이다. 자바 바이트코드의 표현에서 "L;"은 클래스 인스턴스이다.
자바 바이트코드 표현에서 "V"는 반환값이 없음을 의미한다. 
즉, 위 오류 메시지는 java.lang.String 객체 1개를 파라미터로 받고 반환값은 없는 com.nhn.user.UserAdmin.addUser라는 메서드를 찾지 못했다는 의미이다.
애플리케이션 코드는 이전 라이브러리로 컴파일되었으므로, 
"V"를 반환하는 메서드를 호출하도록 class 파일에 기록되어 있지만, 
새로 변경된 라이브러리에서 "V"를 반환하는 메서드는 없어지고, 
"Lcom/nhn/user/User;"를 반환하는 메서드가 추가되었기 때문에 NoSuchMethodError가 발생한 것이다.
이러한 상황이 발행하는 것은 사실 라이브러리 제공자의 잘못이 크다. 반환값이 없다가 생긴것은 하위 호환성이 깨진 것이다.
JVM은 자바 바이트코드를 실행하는 실행기이다.
고수준 언어인 C, C++등의 컴파일러는 직접 CPU에 명령하는 코드를 반환하지만
자바 컴파일러는 플랫폼 의존성을 제거하기 위해 JVM이 인식하는 자바 바이트코드를 반환한다.
컴파일의 결과물의 크기가 소스코드의 크기와 크게 다르지 않기 때문에 네트워크 전송이 쉽다.
자바 바이트코드는 사람이 보기 쉽지 않다. 때문에 JVM벤더들은 JAVAP라는 역어셈블러를 제공한다.


특징 
1.스택기반, 인텔, ARM 아키텍쳐는 레지스터 기반으로 동작하지만 JVM은 스택기반으로 동작.
2.심볼릭 레퍼런스 : 기본 자요형을 제외한 모든 타입을 명시적인 메모리 주소 기반의 레퍼런스가 아니라 심볼릭 레퍼런스를 통해 참조한다.
3.가비지 컬렉션 : 클래스 인스턴스는 사용자 코드에 의해 명시적으로 생성되고 가비지 컬렉션에 의해 자동으로 파괴됨.
4.기본 자료형을 명확하게 정의하여 플랫폼 독립성 보장 : 
C/C++ 같은 경우 플랫폼에 따라 INT형의 크기가 변하지만 
JVM은 기본 자료형을 명확하게 정의하여 호환성 유지.
5.네트워크 바이트 오더 : 자바 클래스 파일은 네트워크 바이트 오더 사용.
이를 통해 하드웨어에 따라 달라지는 환경에서도 플랫폼 독립성을 유지한다.


-runtime data area 구성
method : 클래스 멤버 변수, 메소드 정보, class/interface 정보, static, final 변수등 저장, 상수풀도 존재.
heap : 동적으로 생성되는 오브젝트와 배열이 저장되는 곳 garbage collection의 대상이 되는 영역.
stack : 지역 변수, 파라미터 등이 생성됨 단 실제 객체는 HEAP에 할당되고 레퍼런스만 STACK에 저장됨. 쓰레드 별로 독자적으로 움직임.
(heap에 있는 오브젝트가 stack에서 참조할 수 없는 경우 GC의 대상이 된다.)
pc register : 현재 쓰레드가 실행되는 부분의 주소와 명령을 저장.(CPU의 register는 아님.)
native method stack : 자바외 언어로 작성된 네이티브 코드를 위한 메모리.
=>메모리의 효율적인 사용을 위해서는 참조가 빈번한 것은 method영역에 빈번하지 않은 것은 HEAP영역에 두는 것이 좋다.

-구체적인 실행과정
1.개발자가 .java파일을 생성한다.
2.java 컴파일러가 .java파일을 읽고 .class 파일(바이트 코드)을 생성한다.
3..class 파일을 jvm의 class loader가 runtime data area 형태로 메모리에 적재한다.
4.execution engine가 메모리에 적재된 클래스들을 기계어로 변경해 명령어 단위로 실행한다.
execution engine는 명령어를 하나하나 실행하고 자주 쓸만한 코드를 기계어로 변환 시켜 저장한다.(jit 방식)
5.heap 메모리 영역에 생성된 객체들 중 reachability를 잃은 객체를 탐색후 제거한다.

-classloader
->자바 메모리
메서드 : 모든 스레드가 공유, 클래스의 정보들을 가져와 파싱함. 변수 등 다양한 정보 포함.
힙 : 모든 스레드가 공유, 프로그램을 실행하면서 생성한 객체 인스턴스 저장.
pc(프로그램 카운터) : 각 스레드는 어떤 메서드를 항상 실행하고 있다. pc는 그 메서드안에서 바이트 코드 몇번째 줄을 실행하고 있는지 나타냄.
스택 : 스레드별로 한개 존재, 스택 프레임은 메서드가 호출될 때마다 생성됨.
네이티브 메서드 스택 : 자바 바이트코드가 아닌 c/c++로 작성된 코드를 사용하는 경우 사용되는 베서드이다.
-local variable area 
-operand stack : 
->execution engine<->네이티브 메서드 인터페이스<->네이티브 메서드 라이브러리

-스택과 프레임.
stack과 frame?
jvm이 실행될 때 스레드 별로 스택이 만들어지고 스택에는 메서드가 호출될 때마다 상태 정보를 저장하는 프레임이 들어간다.
스레드가 쓸 수 있는 스택의 사이즈를 넘기게 되면 StackOverflowError가 발생한다.
스택 사이즈를 동적으로 확장할 수도 있는데 확장할 메모리가 부족하거나, 새로운 스레드를 만들 때 필요한 새로운 스택에 할당할 메모리가 부족하면 OutOfMemoryError가 발생한다.
프레임 : 로컬 변수 + operand stack + Constant Pool Reference
