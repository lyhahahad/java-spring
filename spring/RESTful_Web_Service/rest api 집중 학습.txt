https://www.youtube.com/watch?v=RP_f5dMoHFc

하이라이트
1.HATEOAS는 클라이언트가 서버에서 제공하는 모든 미디어 유형과 통신 메커니즘을 이해할 필요가 없도록 하고
상호작용이 대역 외 정보가 아닌 하이퍼 미디어에 의해 주도되도록 한다.


*5줄 요약
rest api는 http의 독립적인 진화를 위해 만들어졌다.
현재의 rest api들은 api의 json에 의해 self-descriptive와 hateoas를 만족하지 못하는 경우가 많다.
self-descriptive란 json의 키값이 무엇을 의미하는지 명확하지 않아 발생하는데 이는 명세를 만들어 해결할 수 있다.
hateoas는 json에 하이퍼링크 명세가 없어 발생하는데 이 또한 명세를 만들어 해결할 수 있다.
api와 달리 웹이 위의 두가지 성질을 만족하는 이유는 html은 모든 것이 명세에 기록돼 해석이 가능하고 하이퍼 링크로 late binding이 가능하기 때문이다.

+a hateoas 추가학습, spring에 hateoas 라이브러리를 사용할 수 있다.
HATEOAS를 통해 클라이언트는 애플리케이션 서버가 하이퍼미디어를 통해 동적으로 정보를 제공하는 네트워크 애플리케이션과 상호 작용합니다 . 
REST 클라이언트는 하이퍼미디어에 대한 일반적인 이해를 넘어 응용 프로그램이나 서버와 상호 작용하는 방법에 대한 사전 지식이 거의 또는 전혀 필요하지 않습니다.
하이퍼 미디어란 그래픽, 오디오, 영상, 텍스트, 하이퍼링크가 포함된다.
다음상태를 응답으로 받은 하이퍼 미디어안에 있는 하이퍼 링크에 의해 주도된다.
클라이언트가 전적으로 서버와 동적인 상호작용이 가능하도록 하는 것
요청에 필요한 URI를 응답에 포함시켜 반환.
RESTful 상호 작용은 대역 외 정보가 아닌 하이퍼미디어에 의해 주도됩니다.
클라이언트는 서버에서 제공하는 모든 미디어 유형과 통신 메커니즘을 이해할 필요가 없습니다. 

*하이라이트
uniform interface가 필요한 이유 : 독립적 진화
독립적 진화 : 서버와 클라이언트가 각각 독립적으로 진화한다.
서버의 기능이 변경되어도 클라이언트를 업데이트할 필요가 없다.
rest를 만들게 된 계기 : "how do i improve http without breaking the web."
rest를 가장 잘 따르며 성장한 것이 웹이다.
rest api는 하이퍼 텍스트를 포함한 self-descriptive한 메시지의 
uniform interface를 통해 리소스에 접근하는 api이다.

-api가 rest를 만족하기 어려운 이유
api는 표현방식이 json이기 때문에 self-descriptive와 hateoas를 만족하기 힘들다.
json의 경우 위에서 살펴본 것처럼 키값이 변하면 그 변한 키값이 무엇인지 클라이언트가 알 수 없다.
html의 경우 div 태그를 p 태그로 바꾼 경우 클라이언트는 p태그가 이미 명세에 나와있기 때문에 클라이언트를 업데이트할 필요가 없다.
json은 하이퍼링크에 대한 명세가 명확하지도 않다.
html의 a태그 같은 것이 없다.

-정리
오늘날 대부분의 rest api는 rest를 따르지 않는다.
self-descriptive와 hateoas를 만족하지 못한다.
rest는 긴 시간에 걸쳐 진화하는 웹 애플리케이션을 위한 것이다.
self-descriptive 미디어타입을 iana에 등록하거나 프로필 링크를 사용해 해결
hateoas는 http헤너다 본문에 링크를 담아 만족시킬 수 있다.


그런 rest api로 괜찮은가?
-어떤 이유로 나왔는가?
1.어떻게 인터넷에서 정보를 공유할 것인가?
=>정보들을 하이퍼 텍스트로 연결한다. http, html, uri.
=>http를 수정하면 기존의 웹하고 호환성 문제 생김.
=>http object model을 통해 그 문제를 해결함.
=>이것이 rest가 됨.(2000년에 논문으로 나옴.)

2.api : 애플리케이션 프로그래밍 인터페이스, 컴퓨터나 컴퓨터 프로그램 사이의 연결이다. 
xml-rpc(1998, 마이크로소프트)->soap.
salesforce api(2000.2, 거의 최초의 api) : 복잡하다.
flickr api(2004.8) : 짧아짐.
soap vs rest
복잡 vs 단순
규칙 많음 vs 적음
어려움 vs 쉬움
=>soap은 줄고 rest가 크게 성장함.
=>2006년 aws는 자사 api 사용량의 85%가 rest임을 밝힘.
그런데 2008년 cmis라는 것이 나옴.
하지만 rest 만든 사람은 그것이 rest가 아니라고 함.
마이크로 소프트에서 발표한 것 역시 그렇게 말함.
=>rest api는 진정 무엇인가?

3.rest 아키텍쳐 스타일
rest 아키텍쳐를 따르는 api
아키텍쳐 스타일은 제약 조건의 집합.
rest는 어떤 제약 조건으로 구성돼 있는가?
-클라이언트 서버, stateless, cache, uniform interface, layered system, code-on-demand(optional, ex) javascript)
uniform interface를 만족하는 것이 힘듦.

4.uniform interface의 제약 조건
identification of resource.(리소스가 uri로 식별되면 된다.)
manipulation of resources through representations.(representations 전송을 통해 리소스를 조정해야 한다.)
아래 두가지는 지켜지기 어려움. 대부분 못지킴.
self-descriptive messages.(메시지는 스스로를 설명해야 한다. 메세지만 보고 무엇인지 확실히 알 수 있어야 한다.)
hyper media  as the engine of application state.(hateoas)(애플리케이션의 상태는 하이퍼링크로 전이돼야 한다.)
애플리케이션 상태의 전이 : 애플리케이션에 하이퍼 링크를 통한 다른 페이지로 넘어갈 수 있는가?
uniform interface가 필요한 이유 : 독립적 진화
독립적 진화 : 서버와 클라이언트가 각각 독립적으로 진화한다.
서버의 기능이 변경되어도 클라이언트를 업데이트할 필요가 없다.
rest를 만들게 된 계기 : "how do i improve http without breaking the web."

*웹, rest가 지켜지고 있는가?
우리가 사용하는 웹은 매우 잘 지키고 있다.
어떤 웹 브라우저를 사용해도 접속이 잘된다.
브라우저를 업데이트 안된다고 접속이 안되지 않는다.
독립적으로 진화한다.
심지어 html 명세가 변경되어도 웹은 잘 동작한다.
앱에서는 rest가 제대로 구현되있지 않아 업데이트를 하지 않으면 동작하지 않는 경우가 많다.
이런 것들이 웹에서 가능한 이유는 w3s 등과 같은 집단 덕분이다.
상호운영성을 위해 엄청 노력한다.
잘못된 이름을 그대로 사용하는 이유이기도 하다.
크롬에서는 http0.9를 아직도 지원함.
이렇듯 웹은 독립적 진화, 상호운용성을 위해 부단히 노력중이다.
-rest가 웹의 독립적 진화에 도움을 주었는가?
http에 지속적으로 영향을 줌.
host 헤더 추가.
http1.1 명세 최신판에는 rest에 대한 언급이 들어감.
-rest는 성공했는가?
웹은 독립적으로 진화하고 있다.
-rest api는 대체로 rest 제약조건을 대체로 모두 만족하지는 않음.
-rest api는 하이퍼 텍스트를 포함한 self-descriptive한 메시지의 
uniform interface를 통해 리소스에 접근하는 api이다.

-꼭 rest api여야 하나?
'시스템 전체를 통제할 수 있거나, 진화에 관심이 없다면 rest를 따지느라 시간을 낭비하지 마라' 로이 필딩

-세가지 선택지
1.rest api를 구현하기.
2.rest api를 포기하고 http api.
3.rest api가 아니지만 rest api라고 부른다.(현재 상태)

-api는 왜 웹페이지와 달리 rest가 힘들까?
api는 기계-기계, json을 사용한다.
html은 사람-기계, html을 사용한다.
json 때문에 rest api 구현이 힘들다.
json은 하이퍼 링크는 정의가 없고 명세가 불완전하다.
기본적인 문법만 정해져있다. 
html은 태그의 의미가 명세에 명확하게 나와있다.
json은 키값이 어떤 것인지 명세에 없다.
iana에 있는 html, json 명세에 찾아갔을 때 거기에 
html 태그의 의미는 있지만 json은 키값이 어떤 것인지는 없다.self-descriptive x
또한 하이퍼 링크가 없기 때문에 hateoas 역시 만족하기 힘들다.

self-descriptive, hateoas가 독립적인 진화에 어떻게 도움이 되는가?
self-descriptive는 확장 가능한 커뮤니케이션이다. 서버가 어떻게 변하든 항상 해석이 가능하다.
json의 경우 위에서 살펴본 것처럼 키값이 변하면 그 변한 키값이 무엇인지 클라이언트가 알 수 없다.
html의 경우 div 태그를 p 태그로 바꾼 경우 클라이언트는 p태그가 이미 명세에 나와있끼 때문에 클라이언트를 업데이트할 필요가 없다.
hateoas는 late binding이 가능해진다.
어디서 어디로 전이가 가능한지 미리 결정되지 않는다.
서버가 링크를 바꿔도 클라이언트의 동작에는 전혀 문제가 없다.

-rest api만들기.
self-descriptive
미디어 타입에 키값을 등록한다, iana에 미디어 타입을 등록할 수 있다.
하지만 이과정은 번거롭다.
다른 방식으로 프로필 링크를 통해 따로 만든 명세를 링크할 수 있다.
하지만 content negotiation을 할 수 없다.
hateoas
본문에 링크를 넣는다. 단점은 링크 표현 방법을 정의해야 한다.
미디어타입, 프로필링크를 사용해야 한다.
중괄호를 사용해 템플릿을 사용할 수도 있다.
json으로 하이퍼 링크를 표현하는 방법이 정의된 명세를 활용한다.
단점 : 명세가 요구하는 것에 맞게 하기 위해 많이 고쳐야 한다.
http 링크, 로케이션 등의 헤더로 링크를 표현한다.
data와 헤더를 사용해 해결할 수 있다.

-하이퍼 링크는 uri여야 하는가?
템플릿도 괜찮음.
미디어 타입 등록 필수인가? no
모두가 알고있다면 괜찮음 하지만 웬만하면 하는게 좋다.

오늘날 대부분의 rest api는 rest를 따르지 않는다.
self-descriptive와 hateoas를 만족하지 못한다.
rest는 긴 시간에 걸쳐 진화하는 웹 애플리케이션을 위한 것이다.
self-descriptive 미디어타입을 iana에 등록하거나 프로필 링크를 사용해 해결
hateoas는 http헤너다 본문에 링크를 담아 만족시킬 수 있다.

+a
캐시(cache)
웹 페이지 요소를 저장하기 위한 임시 장소이다.
캐시는 웹 페이지가 빠르게 렌더링 될 수 있도록 돕는다.
브라우저에만 저장된다.
용량을 많이 차지한다.
브라우저캐시와 프록시 캐시가 있다.
사용자가 직접 수동적으로 삭제해야 한다.
오디오, 비디오, 그림 파일등이 있다.

쿠키(cookie)
캐시와 마찬가지로 정보를 저장하기 위해 사용한다.
웹서버에서 pc로 보내는 작은 파일들을 저장한다.
서버와 브라우저가 모두 저장한다.
용량이 작은 편이다.
일시적 영구적 쿠기가 있다.
쿠키는 누군가 특정한 웹 사이트를 접속할 때 발생한다.
사용자의 인증을 도와준다.
만료 기간이 있어 자동적으로 삭제 된다.
유저의 선호도(로그인 정보, 방문 기록, 방문 횟수)
